<!DOCTYPE html>
<html lang="en">
<head>
<script>
  (function() {
    if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') return;
    var d = new Date(), day = d.getDay(), hm = d.getHours() * 60 + d.getMinutes();
    var open = (day === 5 && hm >= 960 && hm < 1170)
           || (day === 6 && hm >= 450 && hm < 1170)
           || (day === 0 && hm >= 450 && hm < 1020);
    if (!open) window.location.replace('/closed.html');
  })();
</script>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<title>Bloom - By Az</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
  canvas { border: 2px solid #333; border-radius: 8px; display: block; }
  .overlay { position: absolute; color: white; text-align: center; z-index: 10; }
  #titleScreen h1 { font-family: 'Press Start 2P', monospace; font-size: 36px; margin-bottom: 12px; background: linear-gradient(to right, #66eebb, #ffe44d, #ff6ec7); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
  #titleScreen p { font-size: 16px; color: #aaa; margin-bottom: 8px; line-height: 1.6; }
  #titleScreen .byline { font-size: 14px; color: #00ffc8; margin-bottom: 20px; }
  .btn { margin-top: 14px; padding: 14px 40px; font-size: 18px; border: none; border-radius: 12px; cursor: pointer; background: linear-gradient(135deg, #00cc88, #00aa66); color: white; font-weight: bold; transition: transform 0.1s; }
  .btn:hover { transform: scale(1.08); }
  .info { font-size: 12px; color: #666; margin-top: 12px; line-height: 1.8; }
  #endScreen { display: none; }
  #endScreen h1 { font-family: 'Press Start 2P', monospace; font-size: 24px; color: #ffe44d; margin-bottom: 16px; line-height: 1.6; }
  #endScreen p { font-size: 16px; color: #ccc; margin-bottom: 8px; line-height: 1.6; }
  #endScreen .credit { font-size: 14px; color: #00ffc8; margin-top: 16px; }
  .idea-box { margin-top: 20px; padding: 16px 24px; border-radius: 10px; background: rgba(255, 228, 77, 0.08); border: 1px solid rgba(255, 228, 77, 0.2); max-width: 420px; margin-left: auto; margin-right: auto; }
  .idea-box .idea-label { font-family: 'Press Start 2P', monospace; font-size: 9px; color: #ffe44d; margin-bottom: 10px; letter-spacing: 1px; }
  .idea-box .idea-text { font-size: 15px; color: #fff; line-height: 1.6; }
  .btn-small { margin-top: 10px; padding: 8px 20px; font-size: 12px; border: none; border-radius: 8px; cursor: pointer; background: rgba(255, 228, 77, 0.15); color: #ffe44d; font-weight: bold; transition: transform 0.1s, background 0.2s; }
  .btn-small:hover { transform: scale(1.05); background: rgba(255, 228, 77, 0.25); }
  .btn-quit { margin-top: 10px; padding: 14px 40px; font-size: 18px; border: none; border-radius: 12px; cursor: pointer; background: linear-gradient(135deg, #cc4444, #aa2222); color: white; font-weight: bold; transition: transform 0.1s; }
  .btn-quit:hover { transform: scale(1.08); }
  #quitDialog { display: none; }
  #quitDialog h1 { font-family: 'Press Start 2P', monospace; font-size: 24px; color: #fff; margin-bottom: 16px; }
  #quitDialog p { font-size: 18px; color: #aaa; margin-bottom: 8px; font-family: 'Press Start 2P', monospace; }
  .time-display { margin: 16px 0; }
  .time-label { display: block; font-family: 'Press Start 2P', monospace; font-size: 9px; color: #aaa; margin-bottom: 6px; letter-spacing: 1px; }
  .time-value { font-family: 'Press Start 2P', monospace; font-size: 20px; color: #00ffc8; }
  .leaderboard { margin: 16px auto; max-width: 360px; text-align: left; }
  .title-leaderboard { margin: 16px auto; max-width: 360px; text-align: left; }
  .leaderboard-title { font-family: 'Press Start 2P', monospace; font-size: 10px; color: #ffe44d; margin-bottom: 10px; text-align: center; letter-spacing: 1px; }
  .lb-title { font-family: 'Press Start 2P', monospace; font-size: 10px; color: #ffe44d; margin-bottom: 10px; text-align: center; letter-spacing: 1px; }
  .lb-empty { color: #555; font-size: 13px; padding: 8px 0; text-align: center; }
  .lb-row.placeholder { color: #333; }
  .lb-row { display: flex; justify-content: space-between; padding: 4px 8px; font-size: 13px; color: #aaa; font-family: 'Press Start 2P', monospace; }
  .lb-row.highlight { color: #00ffc8; background: rgba(0, 255, 200, 0.08); border-radius: 4px; }
  .lb-name-input { background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: #fff; padding: 6px 10px; font-size: 14px; border-radius: 6px; width: 140px; font-family: 'Press Start 2P', monospace; margin-right: 8px; text-transform: uppercase; }
  .lb-name-input::placeholder { color: rgba(255,255,255,0.3); font-size: 10px; }
  .store-banner { position: fixed; top: 0; left: 0; width: 100%; text-align: center; padding: 6px 0; z-index: 30; background: rgba(0,0,0,0.6); }
  .store-banner a { text-decoration: none; font-family: 'Press Start 2P', monospace; font-size: 12px; background: linear-gradient(to right, #ff6ec7, #00ffc8, #ffe44d); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; opacity: 0.6; transition: opacity 0.2s; }
  .store-banner a:hover { opacity: 1; }
</style>
</head>
<body>
<div class="store-banner"><a href="/">EZ-AZ</a></div>
<div id="titleScreen" class="overlay">
  <h1>BLOOM</h1>
  <p class="byline">By Az</p>
  <p>The world has lost its colour and music.<br>Find the hearts. Bring it back to life.</p>
  <button class="btn" onclick="startGame()">Play</button>
  <div class="info">Arrow keys or WASD to move<br>Hold Shift or Space to sprint<br>Escape to pause</div>
  <div class="title-leaderboard" id="titleLeaderboard"></div>
</div>
<div id="quitDialog" class="overlay">
  <h1>Paused</h1>
  <p id="pauseTimeDisplay"></p>
  <button class="btn" onclick="resumeGame()">Resume</button>
  <button class="btn-quit" onclick="quitGame()">Quit</button>
</div>
<div id="endScreen" class="overlay">
  <h1>The world is alive.</h1>
  <p>You showed up. You paid attention.<br>That's all it took.</p>
  <div class="time-display">
    <span class="time-label">YOUR TIME</span>
    <span class="time-value" id="finalTimeDisplay"></span>
  </div>
  <div id="nameEntrySection" style="display:none; margin-bottom: 12px;">
    <input type="text" id="nameInput" class="lb-name-input" maxlength="10" placeholder="NAME">
    <button class="btn-small" onclick="saveScore()">Save</button>
  </div>
  <div class="leaderboard" id="leaderboardSection"></div>
  <p class="credit">Bloom, by Az. Built at EZ-AZ.</p>
  <div class="idea-box">
    <div class="idea-label">YOUR NEXT GAME COULD BE...</div>
    <div class="idea-text" id="ideaText"></div>
    <button class="btn-small" onclick="showNewIdea()">Another idea</button>
  </div>
  <button class="btn" onclick="window.location.href='/'">Back to the store</button>
</div>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width = 700, H = canvas.height = 800;

// Game state
let state = 'title'; // title, playing, paused, end
let player = { x: 350, y: 400, w: 24, h: 32, facing: 1, frame: 0, frameTimer: 0, moving: false };
let keys = {};
const SPEED = 3;
let gameStartTime = 0;
let totalPausedTime = 0;
let pausedAt = 0;
let finalTime = 0;
let hearts = { clearing: false, forest: false, peaks: false, lake: false, caves: false };
let heartCount = 0;
let currentArea = 'clearing';
let trailPoints = [];
let particles = [];
let audioCtx = null;
let musicLayers = {};
let droneStarted = false;

// Area map layout:
//          forest
// caves    clearing    peaks
//          lake
//          store (locked until 5 hearts)
const areaConnections = {
  clearing: { north: 'forest', south: 'lake', east: 'peaks', west: 'caves' },
  forest:   { south: 'clearing' },
  peaks:    { west: 'clearing' },
  lake:     { north: 'clearing', south: null }, // south opens to store when all hearts found
  caves:    { east: 'clearing' },
  store:    { north: 'lake' }
};

// Colour palettes per area
const areaPalettes = {
  clearing: { bg: [40, 65, 30], ground: [90, 140, 50], accent: [255, 220, 80], name: 'The Clearing' },
  forest:   { bg: [20, 50, 25], ground: [45, 100, 40], accent: [100, 180, 80], name: 'The Forest' },
  peaks:    { bg: [60, 40, 20], ground: [140, 100, 50], accent: [255, 180, 60], name: 'The Peaks' },
  lake:     { bg: [15, 35, 55], ground: [40, 90, 130], accent: [80, 160, 220], name: 'The Lake' },
  caves:    { bg: [20, 10, 35], ground: [60, 30, 90], accent: [160, 80, 220], name: 'The Caves' },
  store:    { bg: [30, 25, 20], ground: [80, 60, 40], accent: [255, 200, 100], name: 'The Store' }
};

// Area data: walls, heart position, bloom state
const areas = {};
function initAreas() {
  // Clearing: C-shaped wall around heart
  areas.clearing = {
    walls: [
      { x: 250, y: 250, w: 200, h: 20 },
      { x: 250, y: 250, w: 20, h: 200 },
      { x: 250, y: 430, w: 200, h: 20 },
    ],
    heart: { x: 380, y: 350, collected: false },
    colourLerp: 0, bloomRadius: 0, bloomOrigin: null,
    elements: []
  };
  // Forest: winding path through tree trunks
  areas.forest = {
    walls: [
      { x: 0, y: 200, w: 250, h: 30 },
      { x: 350, y: 200, w: 350, h: 30 },
      { x: 200, y: 350, w: 300, h: 30 },
      { x: 0, y: 500, w: 200, h: 30 },
      { x: 300, y: 500, w: 400, h: 30 },
      { x: 100, y: 620, w: 400, h: 30 },
    ],
    heart: { x: 550, y: 560, collected: false },
    colourLerp: 0, bloomRadius: 0, bloomOrigin: null,
    elements: []
  };
  // Peaks: zigzag switchback
  areas.peaks = {
    walls: [
      { x: 100, y: 150, w: 500, h: 25 },
      { x: 100, y: 150, w: 25, h: 150 },
      { x: 100, y: 275, w: 400, h: 25 },
      { x: 475, y: 275, w: 25, h: 150 },
      { x: 200, y: 400, w: 300, h: 25 },
      { x: 200, y: 400, w: 25, h: 150 },
      { x: 200, y: 525, w: 350, h: 25 },
    ],
    heart: { x: 350, y: 200, collected: false },
    colourLerp: 0, bloomRadius: 0, bloomOrigin: null,
    elements: []
  };
  // Lake: water with a narrow land bridge to the heart
  areas.lake = {
    walls: [
      // Water (left mass) — starts below the shore
      { x: 0, y: 280, w: 280, h: 370 },
      // Water (right mass)
      { x: 420, y: 280, w: 280, h: 370 },
      // Water pillars narrowing the bridge approach
      { x: 280, y: 280, w: 40, h: 60 },
      { x: 380, y: 280, w: 40, h: 60 },
      // Water below bridge — split to keep the channel open
      { x: 280, y: 420, w: 40, h: 230 },
      { x: 380, y: 420, w: 40, h: 230 },
    ],
    heart: { x: 350, y: 370, collected: false },
    colourLerp: 0, bloomRadius: 0, bloomOrigin: null,
    elements: []
  };
  // Caves: maze with entrance on the right
  areas.caves = {
    walls: [
      // Outer walls (gap on right side for entrance)
      { x: 100, y: 100, w: 500, h: 20 },
      { x: 100, y: 100, w: 20, h: 500 },
      { x: 100, y: 580, w: 500, h: 20 },
      { x: 580, y: 100, w: 20, h: 160 },
      { x: 580, y: 360, w: 20, h: 240 },
      // Inner maze walls
      { x: 200, y: 100, w: 20, h: 180 },
      { x: 200, y: 380, w: 20, h: 200 },
      { x: 300, y: 200, w: 20, h: 200 },
      { x: 400, y: 100, w: 20, h: 160 },
      { x: 400, y: 460, w: 20, h: 120 },
      { x: 500, y: 260, w: 20, h: 220 },
      { x: 300, y: 500, w: 120, h: 20 },
    ],
    heart: { x: 450, y: 200, collected: false },
    colourLerp: 0, bloomRadius: 0, bloomOrigin: null,
    elements: []
  };
  // Store: open room (gap in top wall for entrance from lake)
  areas.store = {
    walls: [
      { x: 50, y: 50, w: 270, h: 20 },
      { x: 380, y: 50, w: 270, h: 20 },
      { x: 50, y: 50, w: 20, h: 600 },
      { x: 50, y: 630, w: 600, h: 20 },
      { x: 630, y: 50, w: 20, h: 600 },
    ],
    heart: null,
    colourLerp: 1, // store is always coloured
    bloomRadius: 9999, bloomOrigin: null,
    elements: []
  };
}

// Colour utilities
function lerpVal(a, b, t) { return Math.round(a + (b - a) * t); }
function lerpColour(grey, colour, t) {
  return `rgb(${lerpVal(grey[0], colour[0], t)},${lerpVal(grey[1], colour[1], t)},${lerpVal(grey[2], colour[2], t)})`;
}
function greyVersion(colour) {
  const avg = Math.round((colour[0] + colour[1] + colour[2]) / 3) * 0.4;
  return [avg, avg, avg + 5];
}

function distFromBloom(x, y, area) {
  if (!area.bloomOrigin) return 9999;
  const dx = x - area.bloomOrigin.x;
  const dy = y - area.bloomOrigin.y;
  return Math.sqrt(dx * dx + dy * dy);
}

function getColourT(x, y, area) {
  if (area.colourLerp >= 1) return 1;
  if (area.bloomRadius <= 0) return 0;
  const d = distFromBloom(x, y, area);
  if (d > area.bloomRadius) return 0;
  return Math.min(1, (area.bloomRadius - d) / 100);
}

// Collision detection
function rectCollide(ax, ay, aw, ah, bx, by, bw, bh) {
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

function collidesWithWalls(x, y, w, h) {
  const area = areas[currentArea];
  if (!area) return false;
  for (const wall of area.walls) {
    if (rectCollide(x, y, w, h, wall.x, wall.y, wall.w, wall.h)) return true;
  }
  return false;
}

// Area transitions
function checkTransition() {
  const margin = 4;
  const conns = areaConnections[currentArea];
  if (!conns) return;
  if (player.y < margin && conns.north) {
    currentArea = conns.north;
    player.y = H - player.h - margin - 2;
  } else if (player.y + player.h > H - margin && conns.south) {
    if (currentArea === 'lake' && conns.south === null && heartCount < 5) return;
    if (currentArea === 'lake' && heartCount >= 5) {
      currentArea = 'store';
      player.y = margin + 2;
    } else if (conns.south) {
      currentArea = conns.south;
      player.y = margin + 2;
    }
  } else if (player.x < margin && conns.west) {
    currentArea = conns.west;
    player.x = W - player.w - margin - 2;
  } else if (player.x + player.w > W - margin && conns.east) {
    currentArea = conns.east;
    player.x = margin + 2;
  }
}

// Heart collection
function checkHeartCollection() {
  const area = areas[currentArea];
  if (!area || !area.heart || area.heart.collected) return;
  const h = area.heart;
  const dx = (player.x + player.w / 2) - h.x;
  const dy = (player.y + player.h / 2) - h.y;
  if (Math.sqrt(dx * dx + dy * dy) < 24) {
    area.heart.collected = true;
    hearts[currentArea] = true;
    heartCount++;
    area.bloomOrigin = { x: h.x, y: h.y };
    // Spawn particles
    for (let i = 0; i < 30; i++) {
      const angle = Math.random() * Math.PI * 2;
      const speed = Math.random() * 3 + 1;
      const palette = areaPalettes[currentArea];
      particles.push({
        x: h.x, y: h.y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 60 + Math.random() * 40,
        colour: palette.accent,
        area: currentArea
      });
    }
    // Play chime
    playHeartChime();
    // Start music layer
    startMusicLayer(currentArea);
    // Open store path if all hearts collected
    if (heartCount >= 5) {
      areaConnections.lake.south = 'store';
    }
  }
}

// Audio system
function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  startDrone();
}

function startDrone() {
  if (droneStarted) return;
  droneStarted = true;
  const now = audioCtx.currentTime;
  // C2 drone
  const osc1 = audioCtx.createOscillator();
  const gain1 = audioCtx.createGain();
  osc1.type = 'sine';
  osc1.frequency.value = 65.41; // C2
  gain1.gain.value = 0.06;
  osc1.connect(gain1);
  gain1.connect(audioCtx.destination);
  osc1.start(now);
  // G2 drone
  const osc2 = audioCtx.createOscillator();
  const gain2 = audioCtx.createGain();
  osc2.type = 'sine';
  osc2.frequency.value = 98.0; // G2
  gain2.gain.value = 0.04;
  osc2.connect(gain2);
  gain2.connect(audioCtx.destination);
  osc2.start(now);
}

// Music layer scheduling
const BPM = 80;
const beatLen = 60 / BPM;
let schedulerTimer = null;
let nextBeatTime = 0;
let beatIndex = 0;

// Note frequencies (C major pentatonic mostly)
const NOTES = {
  C3: 130.81, D3: 146.83, E3: 164.81, G3: 196.0, A3: 220.0,
  C4: 261.63, D4: 293.66, E4: 329.63, G4: 392.0, A4: 440.0,
  C5: 523.25, E5: 659.25, G5: 783.99, C6: 1046.5
};

const layerGains = {};
const layerActive = { clearing: false, forest: false, peaks: false, lake: false, caves: false };

function startMusicLayer(area) {
  layerActive[area] = true;
  if (!layerGains[area]) {
    layerGains[area] = audioCtx.createGain();
    layerGains[area].gain.value = 0;
    layerGains[area].connect(audioCtx.destination);
  }
  layerGains[area].gain.linearRampToValueAtTime(0.12, audioCtx.currentTime + 2);
}

function scheduleMusic() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  while (nextBeatTime < now + 0.1) {
    const beat = beatIndex % 16;

    // Bass (clearing): root notes, quarter notes
    if (layerActive.clearing && layerGains.clearing) {
      const bassNotes = [NOTES.C3, NOTES.C3, NOTES.G3, NOTES.G3, NOTES.A3, NOTES.A3, NOTES.G3, NOTES.G3,
                         NOTES.C3, NOTES.C3, NOTES.E3, NOTES.E3, NOTES.G3, NOTES.G3, NOTES.C3, NOTES.C3];
      if (beat % 4 === 0) {
        playNote(bassNotes[beat], 'sine', nextBeatTime, beatLen * 3.5, layerGains.clearing, 0.15);
      }
    }

    // Melody (forest): pentatonic, half notes on certain beats
    if (layerActive.forest && layerGains.forest) {
      const melodyPattern = [0, -1, 2, -1, 4, -1, 3, -1, 2, -1, 0, -1, 1, -1, 2, -1];
      const melodyNotes = [NOTES.C4, NOTES.D4, NOTES.E4, NOTES.G4, NOTES.A4];
      if (melodyPattern[beat] >= 0) {
        playNote(melodyNotes[melodyPattern[beat]], 'square', nextBeatTime, beatLen * 1.8, layerGains.forest, 0.04);
      }
    }

    // Harmony (peaks): sustained pad chords
    if (layerActive.peaks && layerGains.peaks) {
      if (beat === 0) {
        playNote(NOTES.C4, 'sawtooth', nextBeatTime, beatLen * 8, layerGains.peaks, 0.02);
        playNote(NOTES.E4, 'sawtooth', nextBeatTime, beatLen * 8, layerGains.peaks, 0.02);
        playNote(NOTES.G4, 'sawtooth', nextBeatTime, beatLen * 8, layerGains.peaks, 0.02);
      }
      if (beat === 8) {
        playNote(NOTES.A3, 'sawtooth', nextBeatTime, beatLen * 8, layerGains.peaks, 0.02);
        playNote(NOTES.C4, 'sawtooth', nextBeatTime, beatLen * 8, layerGains.peaks, 0.02);
        playNote(NOTES.E4, 'sawtooth', nextBeatTime, beatLen * 8, layerGains.peaks, 0.02);
      }
    }

    // Percussion (lake): soft hi-hats and kick
    if (layerActive.lake && layerGains.lake) {
      // Hi-hat on every other beat
      if (beat % 2 === 0) {
        playNoise(nextBeatTime, 0.05, layerGains.lake, 0.03);
      }
      // Kick on beat 0 and 8
      if (beat === 0 || beat === 8) {
        playKick(nextBeatTime, layerGains.lake, 0.08);
      }
    }

    // Arp (caves): sixteenth-note arpeggios
    if (layerActive.caves && layerGains.caves) {
      const arpNotes = [NOTES.C4, NOTES.E4, NOTES.G4, NOTES.C5];
      const arpNote = arpNotes[beat % 4];
      playNote(arpNote, 'square', nextBeatTime, beatLen * 0.4, layerGains.caves, 0.025);
    }

    nextBeatTime += beatLen / 4; // sixteenth notes
    beatIndex++;
  }
}

function playNote(freq, type, time, dur, dest, vol) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.value = freq;
  if (type === 'sawtooth') {
    // Detune slightly for warmth
    osc.detune.value = (Math.random() - 0.5) * 10;
  }
  gain.gain.setValueAtTime(vol, time);
  gain.gain.exponentialRampToValueAtTime(0.001, time + dur);
  osc.connect(gain);
  gain.connect(dest);
  osc.start(time);
  osc.stop(time + dur + 0.05);
}

function playNoise(time, dur, dest, vol) {
  const bufferSize = audioCtx.sampleRate * dur;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
  const source = audioCtx.createBufferSource();
  source.buffer = buffer;
  const hp = audioCtx.createBiquadFilter();
  hp.type = 'highpass';
  hp.frequency.value = 7000;
  const gain = audioCtx.createGain();
  gain.gain.setValueAtTime(vol, time);
  gain.gain.exponentialRampToValueAtTime(0.001, time + dur);
  source.connect(hp);
  hp.connect(gain);
  gain.connect(dest);
  source.start(time);
}

function playKick(time, dest, vol) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.frequency.setValueAtTime(120, time);
  osc.frequency.exponentialRampToValueAtTime(30, time + 0.15);
  gain.gain.setValueAtTime(vol, time);
  gain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);
  osc.connect(gain);
  gain.connect(dest);
  osc.start(time);
  osc.stop(time + 0.25);
}

function playHeartChime() {
  const now = audioCtx.currentTime;
  const chimeNotes = [NOTES.C5, NOTES.E5, NOTES.G5, NOTES.C6];
  chimeNotes.forEach(function (freq, i) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.value = freq;
    gain.gain.setValueAtTime(0.15, now + i * 0.12);
    gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.12 + 0.8);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(now + i * 0.12);
    osc.stop(now + i * 0.12 + 0.85);
  });
}

// Drawing functions
function drawArea() {
  const area = areas[currentArea];
  const palette = areaPalettes[currentArea];
  const grey = greyVersion(palette.bg);

  // Background
  const t = area.colourLerp;
  ctx.fillStyle = lerpColour(grey, palette.bg, t);
  ctx.fillRect(0, 0, W, H);

  // Ground details per area
  if (currentArea === 'clearing') drawClearing(area, palette);
  else if (currentArea === 'forest') drawForest(area, palette);
  else if (currentArea === 'peaks') drawPeaks(area, palette);
  else if (currentArea === 'lake') drawLake(area, palette);
  else if (currentArea === 'caves') drawCaves(area, palette);
  else if (currentArea === 'store') drawStore(area, palette);

  // Walls
  drawWalls(area, palette);

  // Colour trail
  drawTrail();

  // Heart
  if (area.heart && !area.heart.collected) {
    drawHeart(area.heart.x, area.heart.y);
  }

  // Particles
  drawParticles();

  // Player
  drawPlayer();

  // HUD
  drawHUD();

  // Area name (fades in briefly on entry)
  drawAreaName(palette.name);
}

let areaNameTimer = 0;
let lastArea = '';

function drawAreaName(name) {
  if (currentArea !== lastArea) {
    lastArea = currentArea;
    areaNameTimer = 120;
  }
  if (areaNameTimer > 0) {
    const alpha = Math.min(1, areaNameTimer / 60);
    ctx.globalAlpha = alpha;
    ctx.font = '14px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#fff';
    ctx.fillText(name, W / 2, H - 30);
    ctx.globalAlpha = 1;
    areaNameTimer--;
  }
}

function drawWalls(area, palette) {
  const greyWall = [50, 50, 55];
  for (const wall of area.walls) {
    const wt = getColourT(wall.x + wall.w / 2, wall.y + wall.h / 2, area);
    if (currentArea === 'lake') {
      // Water walls
      ctx.fillStyle = lerpColour([30, 30, 40], [40, 90, 130], wt);
    } else if (currentArea === 'caves') {
      ctx.fillStyle = lerpColour([25, 20, 30], [50, 35, 65], wt);
    } else if (currentArea === 'store') {
      ctx.fillStyle = '#2a2218';
    } else {
      ctx.fillStyle = lerpColour(greyWall, palette.ground, wt);
    }
    ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
  }
}

function drawClearing(area, palette) {
  const greyGround = greyVersion(palette.ground);
  // Draw grass tufts
  for (let i = 0; i < 40; i++) {
    const gx = (i * 173 + 37) % W;
    const gy = (i * 251 + 89) % H;
    const gt = getColourT(gx, gy, area);
    ctx.fillStyle = lerpColour(greyGround, [120, 170, 60], gt);
    ctx.fillRect(gx, gy, 3, 6);
    ctx.fillRect(gx + 4, gy + 1, 3, 5);
  }
  // Fireflies when lit
  if (area.colourLerp > 0.3) {
    const time = Date.now() / 1000;
    for (let i = 0; i < 8; i++) {
      const fx = 100 + (i * 83) % 500 + Math.sin(time + i) * 20;
      const fy = 100 + (i * 127) % 600 + Math.cos(time * 0.7 + i) * 15;
      const fa = (Math.sin(time * 2 + i * 1.5) + 1) / 2 * area.colourLerp;
      ctx.beginPath();
      ctx.arc(fx, fy, 3, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 255, 150, ${fa * 0.7})`;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(fx, fy, 8, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255, 255, 150, ${fa * 0.15})`;
      ctx.fill();
    }
  }
}

function drawForest(area, palette) {
  // Tree trunks (decorative, on top of walls)
  const treePositions = [
    [60, 160], [180, 160], [400, 160], [550, 160], [650, 160],
    [100, 310], [350, 310], [550, 310],
    [50, 460], [250, 460], [450, 460], [650, 460],
    [150, 590], [400, 590], [600, 590]
  ];
  for (const [tx, ty] of treePositions) {
    const tt = getColourT(tx, ty, area);
    // Trunk
    ctx.fillStyle = lerpColour([35, 30, 30], [90, 60, 30], tt);
    ctx.fillRect(tx - 8, ty, 16, 40);
    // Canopy
    ctx.beginPath();
    ctx.arc(tx, ty - 5, 25, 0, Math.PI * 2);
    ctx.fillStyle = lerpColour([25, 30, 25], [40, 100, 35], tt);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(tx - 10, ty + 5, 20, 0, Math.PI * 2);
    ctx.fillStyle = lerpColour([20, 28, 22], [35, 90, 30], tt);
    ctx.fill();
  }
  // Falling leaves when lit
  if (area.colourLerp > 0.3) {
    const time = Date.now() / 1000;
    for (let i = 0; i < 10; i++) {
      const lx = (i * 73 + time * 20) % W;
      const ly = (i * 100 + time * 30 + Math.sin(time + i) * 40) % H;
      ctx.fillStyle = `rgba(180, 120, 40, ${area.colourLerp * 0.6})`;
      ctx.fillRect(lx, ly, 4, 3);
    }
  }
}

function drawPeaks(area, palette) {
  // Mountain shapes in background
  const peaks = [[100, 120], [300, 100], [500, 130], [650, 110]];
  for (const [px, py] of peaks) {
    const pt = getColourT(px, py, area);
    ctx.beginPath();
    ctx.moveTo(px - 80, H);
    ctx.lineTo(px, py);
    ctx.lineTo(px + 80, H);
    ctx.closePath();
    ctx.fillStyle = lerpColour([40, 38, 35], [100, 70, 35], pt);
    ctx.fill();
    // Snow cap
    ctx.beginPath();
    ctx.moveTo(px - 15, py + 30);
    ctx.lineTo(px, py);
    ctx.lineTo(px + 15, py + 30);
    ctx.closePath();
    ctx.fillStyle = lerpColour([55, 55, 55], [230, 230, 240], pt);
    ctx.fill();
  }
  // Sparkles when lit
  if (area.colourLerp > 0.3) {
    const time = Date.now() / 1000;
    for (let i = 0; i < 12; i++) {
      const sx = (i * 59 + 30) % W;
      const sy = (i * 71 + 50) % H;
      const sa = (Math.sin(time * 3 + i * 2) + 1) / 2 * area.colourLerp;
      ctx.fillStyle = `rgba(255, 220, 100, ${sa * 0.5})`;
      ctx.fillRect(sx - 1, sy - 1, 3, 3);
    }
  }
}

function drawLake(area, palette) {
  // Water effect on wall areas
  if (area.colourLerp > 0) {
    const time = Date.now() / 1000;
    for (const wall of area.walls) {
      const wt = getColourT(wall.x + wall.w / 2, wall.y + wall.h / 2, area);
      // Ripple highlights
      for (let r = 0; r < 5; r++) {
        const rx = wall.x + (r * 61 + 20) % wall.w;
        const ry = wall.y + (r * 47 + 10) % wall.h;
        const ra = Math.sin(time * 2 + r) * 0.3 * wt;
        if (ra > 0) {
          ctx.beginPath();
          ctx.arc(rx, ry, 8 + Math.sin(time + r) * 3, 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(120, 200, 255, ${ra})`;
          ctx.lineWidth = 1;
          ctx.stroke();
        }
      }
    }
    // Lily pads
    const lilyPads = [[150, 350], [500, 300], [100, 500], [580, 450]];
    for (const [lx, ly] of lilyPads) {
      const lt = getColourT(lx, ly, area);
      const bob = Math.sin(time + lx) * 2;
      ctx.beginPath();
      ctx.ellipse(lx, ly + bob, 12, 8, 0, 0.2, Math.PI * 1.8);
      ctx.fillStyle = lerpColour([30, 30, 30], [40, 120, 50], lt);
      ctx.fill();
    }
  }
  // Reeds on shore
  const reedPositions = [[285, 180], [415, 180], [285, 610], [415, 610]];
  for (const [rx, ry] of reedPositions) {
    const rt = getColourT(rx, ry, area);
    const time = Date.now() / 1000;
    for (let r = 0; r < 3; r++) {
      const sway = Math.sin(time + r) * 3 * (area.colourLerp > 0 ? 1 : 0.2);
      ctx.beginPath();
      ctx.moveTo(rx + r * 6, ry);
      ctx.lineTo(rx + r * 6 + sway, ry - 20);
      ctx.strokeStyle = lerpColour([35, 35, 30], [60, 110, 40], rt);
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }
}

function drawCaves(area, palette) {
  // Very dark base
  const baseAlpha = area.colourLerp > 0 ? 0.7 : 0.95;
  ctx.fillStyle = `rgba(5, 3, 10, ${baseAlpha})`;
  ctx.fillRect(0, 0, W, H);

  // Crystals when lit
  if (area.colourLerp > 0) {
    const crystals = [[160, 150], [350, 280], [500, 400], [250, 520], [450, 550], [550, 180]];
    const time = Date.now() / 1000;
    for (const [cx2, cy2] of crystals) {
      const ct = getColourT(cx2, cy2, area);
      const glow = (Math.sin(time * 1.5 + cx2) + 1) / 2 * ct;
      // Crystal shape
      ctx.beginPath();
      ctx.moveTo(cx2, cy2 - 18);
      ctx.lineTo(cx2 - 6, cy2 + 5);
      ctx.lineTo(cx2 + 6, cy2 + 5);
      ctx.closePath();
      ctx.fillStyle = `rgba(160, 80, 220, ${ct * 0.8})`;
      ctx.fill();
      // Glow
      ctx.beginPath();
      ctx.arc(cx2, cy2, 15, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(160, 80, 220, ${glow * 0.2})`;
      ctx.fill();
    }
    // Bioluminescent mushrooms
    const shrooms = [[200, 400], [320, 180], [480, 320], [150, 550], [550, 500]];
    for (const [mx, my] of shrooms) {
      const mt = getColourT(mx, my, area);
      // Stem
      ctx.fillStyle = `rgba(80, 60, 100, ${mt * 0.6})`;
      ctx.fillRect(mx - 2, my, 4, 10);
      // Cap
      ctx.beginPath();
      ctx.arc(mx, my, 8, Math.PI, Math.PI * 2);
      ctx.fillStyle = `rgba(100, 200, 150, ${mt * 0.5})`;
      ctx.fill();
      // Glow
      ctx.beginPath();
      ctx.arc(mx, my, 14, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(100, 200, 150, ${mt * 0.1})`;
      ctx.fill();
    }
  }
}

function drawStore(area, palette) {
  // Warm floor
  ctx.fillStyle = '#2a2218';
  ctx.fillRect(60, 60, 580, 580);

  // Shelf on back wall
  ctx.fillStyle = '#3d2510';
  ctx.fillRect(150, 100, 400, 20);
  ctx.fillRect(150, 200, 400, 20);

  // Tiny game boxes on shelf
  const boxColours = ['#ff6ec7', '#4488ff', '#ffe44d', '#00ffc8', '#ff8844', '#aa66ff'];
  for (let i = 0; i < 6; i++) {
    const bx = 170 + i * 60;
    // Top shelf
    ctx.fillStyle = boxColours[i];
    ctx.fillRect(bx, 75, 20, 25);
    // Bottom shelf
    ctx.fillStyle = boxColours[(i + 3) % 6];
    ctx.fillRect(bx, 175, 20, 25);
  }

  // Counter
  ctx.fillStyle = '#5a3a1a';
  ctx.fillRect(250, 400, 200, 40);
  ctx.fillStyle = '#3d2510';
  ctx.fillRect(250, 440, 200, 60);

  // Neon sign
  const time = Date.now() / 1000;
  const flicker = Math.sin(time * 8) > -0.8 ? 1 : 0.5;
  ctx.font = '20px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.fillStyle = `rgba(0, 255, 200, ${0.8 * flicker})`;
  ctx.fillText('EZ-AZ', W / 2, 290);
  ctx.font = '10px "Press Start 2P", monospace';
  ctx.fillStyle = `rgba(255, 110, 199, ${0.6 * flicker})`;
  ctx.fillText('OPEN', W / 2, 320);

  // Pulsing hint to approach counter
  const hintPulse = 0.5 + Math.sin(time * 2) * 0.3;
  ctx.font = '14px "Press Start 2P", monospace';
  ctx.textAlign = 'center';
  ctx.fillStyle = `rgba(255, 200, 150, ${hintPulse})`;
  ctx.fillText('Come say hi!', W / 2, 380);

  // Check if player reached counter for end state
  if (player.y > 370 && player.y < 460 && player.x > 280 && player.x < 420) {
    if (state === 'playing') {
      state = 'end';
      finalTime = performance.now() - gameStartTime - totalPausedTime;
      document.getElementById('finalTimeDisplay').textContent = formatTime(finalTime);
      document.getElementById('endScreen').style.display = 'block';
      canvas.style.display = 'none';
      showNewIdea();
      showLeaderboard();
    }
  }
}

function drawHeart(hx, hy) {
  const time = Date.now() / 1000;
  const pulse = 1 + Math.sin(time * 3) * 0.1;
  const s = 10 * pulse;

  // Glow
  ctx.beginPath();
  ctx.arc(hx, hy, s + 10, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255, 80, 120, 0.15)';
  ctx.fill();
  ctx.beginPath();
  ctx.arc(hx, hy, s + 5, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(255, 80, 120, 0.25)';
  ctx.fill();

  // Heart shape
  ctx.save();
  ctx.translate(hx, hy);
  ctx.scale(pulse, pulse);
  ctx.beginPath();
  ctx.moveTo(0, 4);
  ctx.bezierCurveTo(-8, -4, -14, -10, -8, -14);
  ctx.bezierCurveTo(-2, -18, 0, -12, 0, -8);
  ctx.bezierCurveTo(0, -12, 2, -18, 8, -14);
  ctx.bezierCurveTo(14, -10, 8, -4, 0, 4);
  ctx.fillStyle = '#ff5080';
  ctx.fill();
  ctx.restore();
}

function drawTrail() {
  for (let i = trailPoints.length - 1; i >= 0; i--) {
    const p = trailPoints[i];
    if (p.area !== currentArea) continue;
    p.life--;
    if (p.life <= 0) { trailPoints.splice(i, 1); continue; }
    const alpha = (p.life / p.maxLife) * 0.3;
    const palette = areaPalettes[currentArea];
    ctx.beginPath();
    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${palette.accent[0]}, ${palette.accent[1]}, ${palette.accent[2]}, ${alpha})`;
    ctx.fill();
  }
}

function drawParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    if (p.area !== currentArea) { i--; continue; }
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.02; // gentle gravity
    p.life--;
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    const alpha = p.life / 100;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${p.colour[0]}, ${p.colour[1]}, ${p.colour[2]}, ${alpha})`;
    ctx.fill();
  }
}

function drawPlayer() {
  const time = Date.now() / 1000;
  const px = player.x;
  const py = player.y;
  const f = player.facing;

  // Idle bob
  const bob = player.moving ? 0 : Math.sin(time * 2) * 1.5;

  ctx.save();
  ctx.translate(px + player.w / 2, py + player.h + bob);
  if (f < 0) ctx.scale(-1, 1);

  // Body
  ctx.fillStyle = '#00cc88';
  ctx.fillRect(-8, -24, 16, 18);

  // Belly
  ctx.fillStyle = '#66eebb';
  ctx.fillRect(-5, -20, 10, 12);

  // Head
  ctx.fillStyle = '#00cc88';
  ctx.beginPath();
  ctx.ellipse(0, -28, 10, 9, 0, 0, Math.PI * 2);
  ctx.fill();

  // Spikes
  ctx.fillStyle = '#00aa66';
  for (let i = -1; i <= 1; i++) {
    ctx.beginPath();
    ctx.moveTo(i * 5 - 2, -35);
    ctx.lineTo(i * 5, -41);
    ctx.lineTo(i * 5 + 2, -35);
    ctx.fill();
  }

  // Eyes
  ctx.fillStyle = 'white';
  ctx.beginPath();
  ctx.ellipse(-4, -30, 3, 3.5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(4, -30, 3, 3.5, 0, 0, Math.PI * 2);
  ctx.fill();

  // Pupils
  ctx.fillStyle = '#111';
  ctx.beginPath();
  ctx.arc(-3, -29.5, 1.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(5, -29.5, 1.5, 0, Math.PI * 2);
  ctx.fill();

  // Smile
  ctx.beginPath();
  ctx.arc(0, -24, 5, 0.1, Math.PI - 0.1);
  ctx.strokeStyle = '#008855';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Feet with walk animation
  const walk = player.moving ? Math.sin(time * 10) * 3 : 0;
  ctx.fillStyle = '#00bb77';
  ctx.fillRect(-8, -6 + walk, 6, 4);
  ctx.fillRect(2, -6 - walk, 6, 4);

  // Arms
  ctx.fillStyle = '#00cc88';
  const armSwing = player.moving ? Math.sin(time * 10) * 8 : 0;
  ctx.save();
  ctx.translate(-9, -18);
  ctx.rotate((10 + armSwing) * Math.PI / 180);
  ctx.fillRect(-2, 0, 4, 8);
  ctx.restore();
  ctx.save();
  ctx.translate(9, -18);
  ctx.rotate((-10 - armSwing) * Math.PI / 180);
  ctx.fillRect(-2, 0, 4, 8);
  ctx.restore();

  // Tail
  ctx.fillStyle = '#00cc88';
  ctx.beginPath();
  ctx.ellipse(-10, -10, 6, 3, -0.3, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawHUD() {
  // Timer top-left
  const elapsed = performance.now() - gameStartTime - totalPausedTime;
  ctx.font = '12px "Press Start 2P", monospace';
  ctx.textAlign = 'left';
  ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
  ctx.fillText(formatTime(elapsed), 10, 24);

  // Heart counter top-right
  const startX = W - 30;
  const startY = 20;
  for (let i = 0; i < 5; i++) {
    const hx = startX - i * 24;
    const filled = heartCount > (4 - i);
    ctx.save();
    ctx.translate(hx, startY);
    ctx.beginPath();
    ctx.moveTo(0, 4);
    ctx.bezierCurveTo(-6, -2, -10, -7, -6, -10);
    ctx.bezierCurveTo(-2, -13, 0, -9, 0, -6);
    ctx.bezierCurveTo(0, -9, 2, -13, 6, -10);
    ctx.bezierCurveTo(10, -7, 6, -2, 0, 4);
    ctx.fillStyle = filled ? '#ff5080' : 'rgba(255, 80, 128, 0.2)';
    ctx.fill();
    if (!filled) {
      ctx.strokeStyle = 'rgba(255, 80, 128, 0.4)';
      ctx.lineWidth = 1;
      ctx.stroke();
    }
    ctx.restore();
  }

  // Store path indicator when all 5 hearts collected
  if (heartCount >= 5 && currentArea === 'lake') {
    const time = Date.now() / 1000;
    const glow = (Math.sin(time * 2) + 1) / 2;
    ctx.fillStyle = `rgba(0, 255, 200, ${0.3 + glow * 0.3})`;
    ctx.fillRect(W / 2 - 30, H - 20, 60, 20);
    ctx.beginPath();
    ctx.moveTo(W / 2 - 10, H - 8);
    ctx.lineTo(W / 2, H - 16);
    ctx.lineTo(W / 2 + 10, H - 8);
    ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + glow * 0.3})`;
    ctx.fill();
  }
}

// Input
document.addEventListener('keydown', function (e) {
  keys[e.key.toLowerCase()] = true;
  // Prevent scrolling
  if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' '].includes(e.key.toLowerCase())) {
    e.preventDefault();
  }
  // Escape to pause/resume
  if (e.key === 'Escape') {
    if (state === 'title') window.location.href = '/';
    else if (state === 'playing') pauseGame();
    else if (state === 'paused') resumeGame();
  }
});
document.addEventListener('keyup', function (e) { keys[e.key.toLowerCase()] = false; });

function updatePlayer() {
  const sprinting = keys['shift'] || keys[' '];
  const speed = sprinting ? SPEED * 2 : SPEED;
  let dx = 0, dy = 0;
  if (keys['arrowleft'] || keys['a']) { dx = -speed; player.facing = -1; }
  if (keys['arrowright'] || keys['d']) { dx = speed; player.facing = 1; }
  if (keys['arrowup'] || keys['w']) dy = -speed;
  if (keys['arrowdown'] || keys['s']) dy = speed;

  player.moving = dx !== 0 || dy !== 0;

  // Try x movement
  const newX = Math.max(0, Math.min(W - player.w, player.x + dx));
  if (!collidesWithWalls(newX, player.y, player.w, player.h)) {
    player.x = newX;
  }
  // Try y movement
  const newY = Math.max(0, Math.min(H - player.h, player.y + dy));
  if (!collidesWithWalls(player.x, newY, player.w, player.h)) {
    player.y = newY;
  }

  // Leave trail
  if (player.moving && Math.random() < 0.3) {
    trailPoints.push({
      x: player.x + player.w / 2,
      y: player.y + player.h,
      life: 120,
      maxLife: 120,
      area: currentArea
    });
  }

  // Keep trail manageable
  if (trailPoints.length > 300) trailPoints.splice(0, 50);
}

// Bloom animation update
function updateBloom() {
  const area = areas[currentArea];
  if (area.bloomOrigin && area.bloomRadius < 1200) {
    area.bloomRadius += 8;
  }
  if (area.bloomOrigin && area.colourLerp < 1) {
    area.colourLerp = Math.min(1, area.colourLerp + 0.008);
  }
}

// Main game loop
function gameLoop() {
  if (state !== 'playing') return;
  updatePlayer();
  checkTransition();
  checkHeartCollection();
  updateBloom();
  scheduleMusic();
  drawArea();
  requestAnimationFrame(gameLoop);
}

function startGame() {
  state = 'playing';
  document.getElementById('titleScreen').style.display = 'none';
  document.getElementById('endScreen').style.display = 'none';
  document.getElementById('quitDialog').style.display = 'none';
  canvas.style.display = 'block';
  initAreas();
  initAudio();
  nextBeatTime = audioCtx.currentTime;
  gameStartTime = performance.now();
  totalPausedTime = 0;
  pausedAt = 0;
  finalTime = 0;
  player.x = 350;
  player.y = 500;
  currentArea = 'clearing';
  heartCount = 0;
  hearts = { clearing: false, forest: false, peaks: false, lake: false, caves: false };
  trailPoints = [];
  particles = [];
  areaConnections.lake.south = null;
  lastArea = '';
  areaNameTimer = 120;
  gameLoop();
}

// Time formatting
function formatTime(ms) {
  const totalSec = Math.max(0, ms / 1000);
  const mins = Math.floor(totalSec / 60);
  const secs = Math.floor(totalSec % 60);
  const millis = Math.floor(ms % 1000);
  return String(mins).padStart(2, '0') + ':' +
         String(secs).padStart(2, '0') + '.' +
         String(millis).padStart(3, '0');
}

// Pause / Resume / Quit
function pauseGame() {
  state = 'paused';
  pausedAt = performance.now();
  const elapsed = pausedAt - gameStartTime - totalPausedTime;
  document.getElementById('pauseTimeDisplay').textContent = formatTime(elapsed);
  document.getElementById('quitDialog').style.display = 'block';
  canvas.style.display = 'none';
}

function resumeGame() {
  totalPausedTime += performance.now() - pausedAt;
  pausedAt = 0;
  state = 'playing';
  document.getElementById('quitDialog').style.display = 'none';
  canvas.style.display = 'block';
  gameLoop();
}

function quitGame() {
  state = 'title';
  document.getElementById('quitDialog').style.display = 'none';
  document.getElementById('titleScreen').style.display = 'block';
  canvas.style.display = 'none';
}

// Leaderboard
function getLeaderboard() {
  try {
    return JSON.parse(localStorage.getItem('bloom-leaderboard') || '[]');
  } catch (e) { return []; }
}

function saveLocalLeaderboard(board) {
  localStorage.setItem('bloom-leaderboard', JSON.stringify(board));
}

async function fetchLeaderboard() {
  try {
    var r = await fetch('/api/scores?game=bloom');
    if (!r.ok) throw new Error();
    var d = await r.json();
    var board = d.scores.map(function (s) { return {name: s.name, time: s.value}; });
    saveLocalLeaderboard(board);
    return board;
  } catch (e) {
    return getLeaderboard();
  }
}

async function showLeaderboard() {
  var board = await fetchLeaderboard();
  var nameEntry = document.getElementById('nameEntrySection');

  var isTopScore = board.length < 10 || finalTime < board[board.length - 1].time;

  if (isTopScore) {
    nameEntry.style.display = 'block';
    document.getElementById('nameInput').value = '';
    document.getElementById('nameInput').focus();
  } else {
    nameEntry.style.display = 'none';
  }

  renderLeaderboard(board, -1);
}

async function saveScore() {
  var input = document.getElementById('nameInput');
  var name = (input.value.trim() || 'ANON').toUpperCase().slice(0, 12);
  var board;
  try {
    var r = await fetch('/api/scores', {method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({game: 'bloom', name: name, value: Math.round(finalTime)})});
    if (!r.ok) throw new Error();
    var d = await r.json();
    board = d.scores.map(function (s) { return {name: s.name, time: s.value}; });
    saveLocalLeaderboard(board);
  } catch (e) {
    board = getLeaderboard();
    board.push({name: name, time: Math.round(finalTime)});
    board.sort(function (a, b) { return a.time - b.time; });
    if (board.length > 10) board.length = 10;
    saveLocalLeaderboard(board);
  }
  document.getElementById('nameEntrySection').style.display = 'none';

  var playerIdx = board.findIndex(function (e) { return e.time === Math.round(finalTime) && e.name === name; });
  renderLeaderboard(board, playerIdx);
}

function renderLeaderboard(board, highlightIdx) {
  var section = document.getElementById('leaderboardSection');
  if (board.length === 0) {
    section.innerHTML = '<div class="leaderboard-title">LEADERBOARD</div><div style="color:#555;font-size:13px;padding:8px 0;">No scores yet. Be the first!</div>';
    return;
  }
  var html = '<div class="leaderboard-title">LEADERBOARD</div>';
  board.forEach(function (entry, i) {
    var cls = i === highlightIdx ? 'lb-row highlight' : 'lb-row';
    html += '<div class="' + cls + '">' +
            '<span>' + (i + 1) + '. ' + entry.name + '</span>' +
            '<span>' + formatTime(entry.time) + '</span></div>';
  });
  section.innerHTML = html;
}

// Load leaderboard on title screen
fetchLeaderboard().then(function (board) {
  var el = document.getElementById('titleLeaderboard');
  if (!el) return;
  var html = '<div class="lb-title">LEADERBOARD</div>';
  if (board.length === 0) {
    html += '<div class="lb-empty">No scores yet. Be the first!</div>';
  }
  board.forEach(function (entry, i) {
    html += '<div class="lb-row"><span>' + (i + 1) + '. ' + entry.name + '</span><span>' + formatTime(entry.time) + '</span></div>';
  });
  for (var i = board.length; i < 10; i++) {
    html += '<div class="lb-row placeholder"><span>' + (i + 1) + '. ---</span><span>-</span></div>';
  }
  el.innerHTML = html;
});

// Game ideas for kids
const gameIdeas = [
  "A game where you're a dog chasing squirrels around a park, but the squirrels keep stealing your bones.",
  "A cooking game where ingredients fall from the sky and you have to catch the right ones to make a recipe before time runs out.",
  "A game where you draw shapes with your mouse and they come alive as creatures that help you solve puzzles.",
  "A two-player game where one person builds a maze and the other has to escape it before a ghost catches them.",
  "A game where you're a bird flying through a storm, collecting lost letters to spell out a secret message.",
  "A music game where you dodge obstacles by pressing keys that play different notes, and the song changes depending on how well you play.",
  "A game where you shrink down to the size of an ant and explore your backyard. A puddle is an ocean. A garden hose is a river.",
  "A tower defence game where instead of weapons, you plant different flowers that slow down or redirect the bugs.",
  "A game where you're a lighthouse keeper and you have to guide ships safely through fog by rotating your light.",
  "A multiplayer game where everyone controls one part of a giant robot — one person does the legs, one does the arms, one does the head.",
  "A game where you're a painter and every brush stroke on the canvas creates terrain that a tiny character has to navigate.",
  "A detective game where you find clues hidden in a picture and piece together what happened.",
  "A racing game where you build your vehicle out of junk you find along the track — wheels, rockets, springs, umbrellas.",
  "A game where day and night cycle every 30 seconds and different creatures appear at different times.",
  "A game where you're a cloud and you have to rain on the right gardens to help flowers grow, but avoid raining on the people having picnics.",
  "A game where gravity keeps flipping and you have to reach the exit of each room before it flips again.",
  "A rhythm game where your character dances through a level, and the platforms only appear if you tap in time with the beat.",
  "A game where two siblings ride a tandem bike — one steers, one pedals — and they have to work together to deliver packages.",
  "A game where you're a gecko on a wall and you stick to surfaces, jumping between ceilings, walls, and floors to dodge things.",
  "A game where you explore the ocean floor in a tiny submarine, discovering glowing fish and sunken treasure.",
];

let lastIdeaIndex = -1;
function showNewIdea() {
  let idx;
  do { idx = Math.floor(Math.random() * gameIdeas.length); } while (idx === lastIdeaIndex);
  lastIdeaIndex = idx;
  document.getElementById('ideaText').textContent = gameIdeas[idx];
}
</script>
</body>
</html>
